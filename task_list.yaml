TODO
^^^^

Passwords:
Implement passwords design in retroshare (store locally if I still have DHT issues)
- [Done] implement account creation
  - [Done] 3: KKS ← generateKey()
           KKS used to encrypt FKS, the encrypted file with PGP data
  - [Done] 4: FKS ← encryptKKS (Kx1||Kx2|| . . .)
           encrypt PGP auth data into FKS
  - [Done] 5: fKS ← Storage.create(FKS)
           write FKS (encrypted PGP auth data) into local storage
  - [Done] 6: salt ← generateSalt()
  - [Done] 8: KLI ← KDF(salt,passwd)
           keyDerivationFunction() uses SHA1 to generate KLI from salt and password
  - [Done] 9: KW ← generateKey() // suitable for the storage system
  - [Done] 10: FLI ← salt||encrypt(KLI) (fKS||KKS||KW ||devmap)
    - [Done] implement fn which concatenates the salt + data buffers and returns as a single buffer
    - [Done] Encrypt concatenated data [salt||encrypt(KLI, (fKS||KKS||KW))] using using symmetric key KLI (aes encrypt/decrypt)
  - [Done] 11: fLI ← Storage.create(FLI) - using KW
           write the fLI file to disk/storage/DHT
  - [Done] 12: while DHT.put(uname, fLI) fails
- [Done] test account creation
  - [Done] test encrypt/decrypt input/output match (i.e. encrypt/decrypt do not mangle data)
  - [Done] test keyDerivationFunction: KLI ← KDF(salt,passwd)
  - [Done (sorta)] move the test into a proper unittest
    - [Done] I tried to already but hit issues with relative includes for the project.
- [Done] hook into retroshare main executable
- [Done] implement login
  - [Done] interactive login
    - [Done] 10: fLI ← DHT.get(uname)
    - [Done] 11: FLI ← Storage.read(fLI)
    - [Done] decrypt metadata file
      - [Done] 12: salt ← FLI.salt // stored in plaintext
      - [Done] 13: KLI ← KDF(salt,passwd)
      - [Done] 14: fKS, KKS, KW, devmap ← decryptKLI (FLI)
    - [Done] unittest case

- DHT time!

- save entire PGP key
  - [Done] currently saving only public part of PGP key. Look at what is in a PGP key,
  - add entire PGP key into FKS
  - locate in code where retroshare loads the local PGP key
- update from local storage to using DHT storage
- move the metadata file and key store file into their own classes
  and have those classes know how to serialise/deserialize their data.

- Implement multi device login
  Login devmap in metadata.
  Allows multiple devices to save log in credentials and
  user to revoke all devices via devmap.
  - save login credentials Locally
    - implement devmap in metadata file (FLI)
  - 1: fDL, KDL ← Device.readLocalStore()
  - 2: if fDL "= NULL then // non-interactive login
  - 3: FDL ← Storage.read(fDL)
  - 4: fKS, KKS ← decryptKDL(FDL)
  - 5: saveLoginLocally ← False
  - 16: FKS ← Storage.read(fKS)
  - 17: Kx1, Kx2,... ← decryptKKS (FKS)
  - 18: if saveLoginLocally then
  - 19: KDL ← generateKey()
  - 20: FDL ← encryptKDL(fKS||KKS)
  - 21: fDL ← Storage.create(FDL)
  - 22: Device.writeLocalStore(fDL||KDL)
  - 23: devmap.append(Device.ID, fDL||KDL)
  - 24: FLI ← salt||encryptKLI (fKS||KKS||KW||devmap)
  - 25: Storage.write(fLI,FLI) // using KW
  - 26: end if
  - write unittest case


DHT:
- get_hash
  - 4 messages required:
    - [Done] msgout_get_hash
      implemented but not hooked up
      // get_hash (bittorrent get_peers) - get a value for a key from the DHT
      void msgout_get_hash(bdId *id, bdToken *transId, bdNodeId *info_hash);
      - [Done] add a bdNode::send_get_hash_query() fn to call it
      - [Done] make sure it passes through the correct params for msgout_get_hash
    - [Done] msgin_get_hash
      implemented and hooked up
      void msgin_get_hash(bdId *id, bdToken *transId, bdNodeId *nodeid);
    - msgout_reply_hash
      Implemented, but not hooked up in processRemoteQuery.
      When called it will need to be passed the hash value to return,
      which seems to be a list of strings.
      void msgout_reply_hash(bdId *id, bdToken *transId,
                             bdToken *token, std::list<std::string> &values);
      - processRemoteQuery needs to read the value for the given hash(key)
        from local hash store.
        - where on earth is the local hash store?
        - read from it and pass the found hash value to msgout_reply_hash()
        - NOTE: this is where normally it reads all of the ip:ports of the
          peers that are downloading the bittorrent filehash. In this new
          PasswordsAuth version the data we want to fetch is not a
          std::list<std::string> &values
          like in bdNode.cc, but instead is a char* (an encrypted file).
          - update processRemoteQuery to fetch and return a single blob
          - update msgout_reply_hash to handle/expect a single blob
          - update msgin_reply_hash to handle/expect a single blob
          - possibly rename all of these fns to reflect the fact that they're a
            special case and not the standard gethash fn call?
          - possibly change the messageID of these messages to also reflect
            that fact, it also means that these new msgs won't get confused
            with the standard getHash set of messages.

    - msgin_reply_hash
      hooked up, but doesn't extract hash from msg
      void msgin_reply_hash(bdId *id, bdToken *transId,
                            bdToken *token, std::list<std::string> &values);
      - [Done] need to return query results to original query code.
        How does RS code do this? Check find_peer() code.
        bdNode is already the place to handle this code, so it calls the code
        directly to bdNode::addPeer()
      - [Done] add a fn call to PasswordsAuth::getHashCallback()
      - check base message format, this fn expects a list of strings which are
        probably ip:ports of the bittorrent peers downloading that file info_hash.
        How will this work with our case, when we're returning a single 'file' blob

    - PasswordsAuth update to handle async messages & callbacks
      Need to break each place in PasswordsAuth() which does a getHash into two fns:
      - DHT getHash
      - setHashResult
      - get uname->fLI
      - get fLI->FLI
      - get kKS->KKS

  - hook up to RS code
    - bdNode::send_get_hash_query()
      where in RS should call this? need to go through managers code to see
      what should call it
    - add code to rsinit(?) which sends a gethash() query

- BOLLOCKS: HOW THE DO I MAKE SURE THAT ONE OF MY DEBUG DHT NODES IS THE
  ONE THAT HANDLES THE GET_HASH() OR POST_HASH() QUERY?

- post hash
    // post hash should determine the filename (i.e. key) if possible
    // post_hash (bittorrent announce_peers) - write a key:value to the DHT
    // TODO: implemented but not hooked up, will need to give it a key:value to write
    void msgout_post_hash(bdId *id, bdToken *transId, bdNodeId *info_hash,
    // TODO: hooked up to recv() but does nothing.
    //       It should queue a query which then calls msgout_reply_post
    void msgin_post_hash(bdId *id,  bdToken *transId,
                         bdNodeId *info_hash,  uint32_t port, bdToken *token);
    // TODO: not queued by msgin_post_hash
    //       need to add code to processRemoteQuery to handle sending this response
    void msgout_reply_post(bdId *id, bdToken *transId);
    // TODO: hooked up to recv()? but does nothing.
    void msgin_reply_post(bdId *id, bdToken *transId);

- Then unittest or get RS into a test case to verify we get or send data.
  If this doesn't work out of the box, debugging could take a _lot_ of time.

- [Done] need to trace through how queries and results are handled
  bdiface::libbitdht/src/bitdht/bdiface.h
  class BitDhtCallback:
      dhtPeerCallback
      dhtValueCallback
      dhtInfoCallback
- [Done] how to send queries:
  bdNode::send_query(bdId *id, bdNodeId *targetNodeId)
  msgout_find_node(id, &transId, targetNodeId);
  - trying to figure out the stack/how/when bitdht sends a find_node message
  - it appears to be the only handled incoming message in bdnode? surely not, rs must support the other bittorrent calls right?
  - even if find_node is enough, how do you go from find_node to getting a key:value from the find_node call? I don't think you can.

paper notes:
- distributed storage allows for brute forcing
- why is the salt in plaintext, makes it easier to hack/brute force
- what determines the message type enum values? they must be shared with bittorrent, otherwise the bittorrent nodes wouldn't be able to handle them. The message format must be shared too.
- retroshare uses a node entry to hold the IP, so they don't actually write to the DHT key:value.
